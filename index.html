<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BTC/USDT — Dow Theory (Daily, Adaptive)</title>
<style>
  :root { color-scheme: dark; }
  body{margin:0;background:#0f1115;color:#e6e6e6;font-family:Arial,Helvetica,sans-serif}
  .wrap{max-width:1080px;margin:18px auto;padding:0 14px}
  .topline{margin:0 0 8px;font-size:14px;color:#ffcc70;font-weight:600}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  .card{background:#171a21;border:1px solid #262b36;border-radius:12px;padding:10px}
  canvas{width:100%;height:460px;background:#0f1115;border-radius:10px}
  .small{font-size:12px;color:#9aa0a6}
  .k{color:#9aa0a6}
  .v{font-weight:bold}
  .up{color:#7fd18b}
  .down{color:#ff8b8b}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;margin-inline-start:8px;background:#222a}
  .bd-up{color:#7fd18b;border:1px solid #7fd18b55}
  .bd-down{color:#ff8b8b;border:1px solid #ff8b8b55}
  .b{font-weight:700}
  hr{border:0;border-top:1px solid #262b36;margin:10px 0}
  .panels{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px}
</style>
</head>
<body>
<div class="wrap">
  <!-- Only your name above the chart -->
  <div class="topline">Made by <b>Anas Alwadi</b></div>

  <div class="grid">
    <div class="card">
      <canvas id="chart" width="1000" height="460" aria-label="BTC chart"></canvas>
      <div id="dyn" class="small" style="margin-top:6px"></div>
      <div id="asof" class="small"></div>
    </div>

    <div class="card">
      <div id="status" class="small">Loading…</div>
      <hr>
      <div class="panels" id="report"></div>
      <hr>
      <div id="hint" class="small"></div>
    </div>
  </div>
</div>

<script>
// ===== Data source (CORS friendly) =====
const API = "https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USDT&limit=2000";

// ===== Helpers =====
const fmtDate = ts => new Date(ts*1000).toISOString().slice(0,10);
const pct = x => (x*100).toFixed(2) + "%";
const daysBetween = (aTS,bTS) => Math.max(0, Math.round((bTS-aTS)/86400));
const last = arr => arr[arr.length-1];
const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));

// ATR-14% of price
function trueRange(prevClose, high, low){
  const a = high - low, b = Math.abs(high - prevClose), c = Math.abs(low - prevClose);
  return Math.max(a,b,c);
}
function atr14Percent(candles){
  if(candles.length < 15) return 0.10;
  const trs = [];
  for(let i=1;i<candles.length;i++) trs.push(trueRange(candles[i-1].close, candles[i].high, candles[i].low));
  const atrs = [];
  for(let i=13;i<trs.length;i++){ let s=0; for(let k=i-13;k<=i;k++) s+=trs[k]; atrs.push(s/14); }
  const atr = last(atrs), ref = last(candles).close || 1;
  return atr / ref;
}

// ZigZag on close with reversal %
function zigzag(candles, revPct){
  const series = candles.map(c=>({t:c.time, p:c.close}));
  if(series.length<2) return {pivots:[], segments:[]};
  let pivots=[], trend=null, extreme = {...series[0]};
  for(let i=1;i<series.length;i++){
    const {t,p}=series[i];
    if(trend===null){
      const up=(p-extreme.p)/extreme.p, dn=(extreme.p-p)/extreme.p;
      if(up>=revPct){ trend="up"; pivots.push({t:extreme.t,p:extreme.p,type:"low"}); extreme={t,p}; }
      else if(dn>=revPct){ trend="down"; pivots.push({t:extreme.t,p:extreme.p,type:"high"}); extreme={t,p}; }
      else{ if(p>extreme.p) extreme={t,p}; if(p<extreme.p) extreme={t,p}; }
      continue;
    }
    if(trend==="up"){
      if(p>extreme.p) extreme={t,p};
      else if((extreme.p-p)/extreme.p >= revPct){ pivots.push({t:extreme.t,p:extreme.p,type:"high"}); trend="down"; extreme={t,p}; }
    }else{
      if(p<extreme.p) extreme={t,p};
      else if((p-extreme.p)/extreme.p >= revPct){ pivots.push({t:extreme.t,p:extreme.p,type:"low"}); trend="up"; extreme={t,p}; }
    }
  }
  pivots.push({t:extreme.t,p:extreme.p,type:trend==="up"?"high":"low"});
  const segments=[];
  for(let i=0;i<pivots.length-1;i++){
    const A=pivots[i], B=pivots[i+1];
    const dir = (A.type==="low"&&B.type==="high")?"up":(A.type==="high"&&B.type==="low")?"down":(B.p>A.p?"up":"down");
    segments.push({dir,startTS:A.t,endTS:B.t,start:A.p,end:B.p,change:(B.p-A.p)/A.p,days:daysBetween(A.t,B.t)});
  }
  return {pivots,segments};
}

// Class windows (added Strong Major = 91–360d)
const CFG = {
  primary:      { name:"Primary",       minDays:365, maxDays:Infinity },
  strongMajor:  { name:"Strong Major",  minDays:91,  maxDays:360     },
  major:        { name:"Major",         minDays:21,  maxDays:90      },
  minor:        { name:"Minor",         minDays:2,   maxDays:Infinity }
};

// Pick latest segment matching a class
function pickLatestForClass(segments, cls){
  for(let i=segments.length-1;i>=0;i--){
    const s=segments[i];
    if(s.days>=cls.minDays && s.days<=cls.maxDays) return {idx:i, seg:s};
  }
  return null;
}

// --- Cancellation rules ---
// 1) Primary cancels only by later opposite Primary (unchanged)
function cancelledPrimary(segPrim, pickIdx){
  if(pickIdx==null || pickIdx<0) return false;
  const picked=segPrim[pickIdx];
  for(let j=pickIdx+1;j<segPrim.length;j++){
    const s=segPrim[j];
    const same = s.days>=CFG.primary.minDays;
    if(!same) continue;
    if(s.dir!==picked.dir) return true;
  }
  return false;
}
// 2) Minor cancels only by later opposite Minor (unchanged)
function cancelledMinor(segMinor, pickIdx){
  if(pickIdx==null || pickIdx<0) return false;
  const picked=segMinor[pickIdx];
  for(let j=pickIdx+1;j<segMinor.length;j++){
    const s=segMinor[j];
    const same = s.days>=CFG.minor.minDays;
    if(!same) continue;
    if(s.dir!==picked.dir) return true;
  }
  return false;
}
// 3) Major cancels by later opposite Major OR later opposite Strong Major
function cancelledMajorByMajorOrStrong(segMajors, pickMIdx){
  if(pickMIdx==null || pickMIdx<0) return false;
  const picked = segMajors[pickMIdx];
  for(let j=pickMIdx+1;j<segMajors.length;j++){
    const s = segMajors[j];
    const isMajor      = (s.days>=CFG.major.minDays && s.days<=CFG.major.maxDays);
    const isStrongMaj  = (s.days>=CFG.strongMajor.minDays && s.days<=CFG.strongMajor.maxDays);
    if(!(isMajor || isStrongMaj)) continue;
    if(s.dir!==picked.dir) return true;
  }
  return false;
}

// If there is a later Major (any direction) after a Strong Major → hide Strong Major
function shouldHideStrongMajor(pickSMIdx, pickMIdx){
  if(pickSMIdx==null || pickSMIdx<0) return false;
  if(pickMIdx==null || pickMIdx<0) return false;
  return pickMIdx > pickSMIdx; // newer Major exists → hide Strong Major panel
}

// Trading hint (unchanged)
function tradingHint(majorPick, majorCancelled, minorSegments){
  if(!majorPick || majorCancelled || majorPick.seg.dir!=="up") return {text:"Wait for an up Major trend to follow the rule.", ok:false};
  const mLast = last(minorSegments);
  const mPrev = minorSegments.length>1 ? minorSegments[minorSegments.length-2] : null;
  if(!mLast || !mPrev) return {text:"Need more Minor data.", ok:false};
  if(mPrev.dir==="down" && mLast.dir==="up") return {text:"Major is UP and down-Minor just broke → LONG signal.", ok:true};
  if(mLast.dir==="down") return {text:"Major is UP but Minor is DOWN now → wait for an upside break.", ok:false};
  return {text:"Major is UP and Minor is UP (no fresh break).", ok:false};
}

// Canvas chart
function drawChart(canvas, candles, pivots){
  const ctx=canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;
  ctx.clearRect(0,0,W,H);
  const padL=50, padR=10, padT=10, padB=24;

  const xs=candles.map(c=>c.time), ys=candles.map(c=>c.close);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const x0=xs[0], x1=xs[xs.length-1];
  const xScale = t => padL + ( (t-x0)/(x1-x0) )*(W-padL-padR);
  const yScale = p => H-padB - ((p-minY)/(maxY-minY))*(H-padT-padB);

  // grid
  ctx.strokeStyle="#1f2430"; ctx.lineWidth=1;
  for(let i=0;i<=5;i++){
    const y=padT+i*(H-padT-padB)/5;
    ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(W-padR,y); ctx.stroke();
  }

  // price line
  ctx.strokeStyle="#8ab4f8"; ctx.lineWidth=1.5; ctx.beginPath();
  candles.forEach((c,i)=>{
    const x=xScale(c.time), y=yScale(c.close);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // pivots
  pivots.forEach(p=>{
    const x=xScale(p.t), y=yScale(p.p);
    ctx.fillStyle = p.type==="high" ? "#ff8b8b" : "#7fd18b";
    ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
  });

  // y labels
  ctx.fillStyle="#9aa0a6"; ctx.font="11px Arial";
  ctx.fillText(maxY.toLocaleString(), 6, yScale(maxY)+4);
  ctx.fillText(minY.toLocaleString(), 6, yScale(minY)+12);
}

async function run(){
  const status=document.getElementById("status");
  try{
    status.textContent="Fetching daily candles…";
    const res=await fetch(API,{cache:"no-store"});
    if(!res.ok) throw new Error("HTTP "+res.status);
    const js=await res.json();
    if(js.Response!=="Success") throw new Error("API error");
    const candles = js.Data.Data;

    // Adaptive thresholds
    const atrp = atr14Percent(candles);
    const revMinor   = clamp(2.5*atrp, 0.06, 0.20);
    const revMajor   = clamp(5.0*atrp, 0.15, 0.40);
    const revPrimary = clamp(8.0*atrp, 0.20, 0.60);

    // ZigZag per class (Major threshold used for Major & Strong Major)
    const zzMinor    = zigzag(candles, revMinor);
    const zzMajors   = zigzag(candles, revMajor);
    const zzPrimary  = zigzag(candles, revPrimary);

    const segMinor   = zzMinor.segments;
    const segMajors  = zzMajors.segments;
    const segPrimary = zzPrimary.segments;

    const pickm  = pickLatestForClass(segMinor,   CFG.minor);
    const pickM  = pickLatestForClass(segMajors,  CFG.major);
    const pickSM = pickLatestForClass(segMajors,  CFG.strongMajor);
    const pickP  = pickLatestForClass(segPrimary, CFG.primary);

    const cancelledm = pickm ? cancelledMinor(segMinor, pickm.idx) : false;
    const cancelledP = pickP ? cancelledPrimary(segPrimary, pickP.idx) : false;
    const cancelledM = pickM ? cancelledMajorByMajorOrStrong(segMajors, pickM.idx) : false;

    // Hide Strong Major if there is a later Major
    const hideStrong = (pickSM && pickM && shouldHideStrongMajor(pickSM.idx, pickM.idx));

    // Build report
    const report=document.getElementById("report");
    function block(label, pick, cancelled){
      if(!pick) return `<div class="small"><span class="k">${label} trend</span><div>No segment matches the duration.</div></div>`;
      const s=pick.seg, dirCls=s.dir==="up"?"up":"down";
      const badge = s.dir==="up" ? `<span class="badge bd-up">UP</span>` : `<span class="badge bd-down">DOWN</span>`;
      return `
        <div>
          <div class="${dirCls} v" style="font-size:16px;margin-bottom:4px">${label} trend ${badge}</div>
          <div><span class="k">From:</span> ${fmtDate(s.startTS)} @ ${s.start.toLocaleString()}</div>
          <div><span class="k">To:</span> ${fmtDate(s.endTS)} @ ${s.end.toLocaleString()}</div>
          <div><span class="k">Change:</span> ${pct(s.change)} · <span class="k">Days:</span> ${s.days}</div>
          <div><span class="k">Status:</span> ${cancelled ? "Cancelled by opposite later trend (per rules)" : "Active"}</div>
        </div>
      `;
    }
    report.innerHTML =
        block("Primary", pickP, cancelledP)
      + (hideStrong ? "" : block("Strong Major", pickSM, false))
      + block("Major",   pickM, cancelledM)
      + block("Minor",   pickm, cancelledm);

    // Trading hint
    const hint = (pickM ? (pickM.seg.dir==="up" && !cancelledM) : false)
      ? (function(){
          const mLast = last(segMinor), mPrev = segMinor.length>1 ? segMinor[segMinor.length-2] : null;
          if(mPrev && mLast && mPrev.dir==="down" && mLast.dir==="up")
            return {text:"Major is UP and down-Minor just broke → LONG signal.", ok:true};
          if(mLast && mLast.dir==="down")
            return {text:"Major is UP but Minor is DOWN now → wait for an upside break.", ok:false};
          return {text:"Major is UP and Minor is UP (no fresh break).", ok:false};
        })()
      : {text:"Wait for an up Major trend to follow the rule.", ok:false};
    document.getElementById("hint").innerHTML = `<div class="${hint.ok?'up':'k'}">${hint.text}</div>`;

    // Chart
    const cv=document.getElementById("chart");
    drawChart(cv, candles, zzMinor.pivots);

    // Info
    document.getElementById("dyn").innerHTML =
      `ATR-14%: <span class="b">${(atrp*100).toFixed(2)}%</span> · `
    + `rev Minor: <span class="b">${(revMinor*100).toFixed(1)}%</span> · `
    + `rev Major: <span class="b">${(revMajor*100).toFixed(1)}%</span> · `
    + `rev Primary: <span class="b">${(revPrimary*100).toFixed(1)}%</span>`;
    document.getElementById("asof").textContent = "Last candle: " + fmtDate(last(candles).time);

    document.getElementById("status").textContent = "Done.";
  }catch(e){
    console.error(e);
    document.getElementById("status").textContent = "Error: " + (e.message || e);
  }
}

run();
</script>
</body>
</html>
